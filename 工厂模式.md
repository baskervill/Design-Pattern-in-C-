# 设计模式C++实现（1）——工厂模式

​       软件领域中的设计模式为开发人员提供了一种使用专家设计经验的有效途径。设计模式中运用了面向对象编程语言的重要特性：封装、继承、多态，真正领悟设计模式的精髓是可能一个漫长的过程，需要大量实践经验的积累。最近看设计模式的书，对于每个模式，用C++写了个小例子，加深一下理解。主要参考《大话设计模式》和《设计模式:可复用面向对象软件的基础》两本书。本文介绍工厂模式的实现。

​       工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。听上去差不多，都是工厂模式。下面一个个介绍，首先介绍简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。有点抽象，举个例子就明白了。有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。下面给出一种实现方案。

1. enum CTYPE {COREA, COREB};     
2. class SingleCore    
3. {    
4. public:    
5. ​    virtual void Show() = 0;  
6. };    
7.   
8. class SingleCoreA: public SingleCore    
9. {    
10. public:    
11. ​    void Show() { cout<<"SingleCore A"<<endl; }    
12. };    
13.   
14. class SingleCoreB: public SingleCore    
15. {    
16. public:    
17. ​    void Show() { cout<<"SingleCore B"<<endl; }    
18. };    
19.   
20. class Factory    
21. {    
22. public:     
23. ​    SingleCore* CreateSingleCore(enum CTYPE ctype)    
24. ​    {    
25. ​        if(ctype == COREA)   
26. ​            return new SingleCoreA();   
27. ​        else if(ctype == COREB)    
28. ​            return new SingleCoreB();   
29. ​        else    
30. ​            return NULL;    
31. ​    }    
32. };    

​       这样设计的主要缺点之前也提到过，就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。于是，工厂方法模式出现了。所谓工厂方法模式，是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

​       听起来很抽象，还是以刚才的例子解释。这家生产处理器核的产家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面给出一个实现方案。

1. class SingleCore    
2. {    
3. public:    
4. ​    virtual void Show() = 0;  
5. };    
6.   
7. class SingleCoreA: public SingleCore    
8. {    
9. public:    
10. ​    void Show() { cout<<"SingleCore A"<<endl; }    
11. };    
12.   
13. class SingleCoreB: public SingleCore    
14. {    
15. public:    
16. ​    void Show() { cout<<"SingleCore B"<<endl; }    
17. };    
18. class Factory    
19. {    
20. public:    
21. ​    virtual SingleCore* CreateSingleCore() = 0;  
22. };    
23.   
24. class FactoryA: public Factory    
25. {    
26. public:    
27. ​    SingleCoreA* CreateSingleCore() { return new SingleCoreA; }    
28. };    
29.   
30. class FactoryB: public Factory    
31. {    
32. public:    
33. ​    SingleCoreB* CreateSingleCore() { return new SingleCoreB; }    
34. };    

​       工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。

​       既然有了简单工厂模式和工厂方法模式，为什么还要有抽象工厂模式呢？它到底有什么作用呢？还是举这个例子，这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器，下面给出实现的代码。

1.   
2. class SingleCore     
3. {    
4. public:    
5. ​    virtual void Show() = 0;  
6. };    
7. class SingleCoreA: public SingleCore      
8. {    
9. public:    
10. ​    void Show() { cout<<"Single Core A"<<endl; }    
11. };    
12. class SingleCoreB :public SingleCore    
13. {    
14. public:    
15. ​    void Show() { cout<<"Single Core B"<<endl; }    
16. };    
17.   
18. class MultiCore      
19. {    
20. public:    
21. ​    virtual void Show() = 0;  
22. };    
23. class MultiCoreA : public MultiCore      
24. {    
25. public:    
26. ​    void Show() { cout<<"Multi Core A"<<endl; }    
27. ​    
28. };    
29. class MultiCoreB : public MultiCore      
30. {    
31. public:    
32. ​    void Show() { cout<<"Multi Core B"<<endl; }    
33. };    
34.   
35. class CoreFactory      
36. {    
37. public:    
38. ​    virtual SingleCore* CreateSingleCore() = 0;  
39. ​    virtual MultiCore* CreateMultiCore() = 0;  
40. };    
41.   
42. class FactoryA :public CoreFactory    
43. {    
44. public:    
45. ​    SingleCore* CreateSingleCore() { return new SingleCoreA(); }    
46. ​    MultiCore* CreateMultiCore() { return new MultiCoreA(); }    
47. };    
48.   
49. class FactoryB : public CoreFactory    
50. {    
51. public:    
52. ​    SingleCore* CreateSingleCore() { return new SingleCoreB(); }    
53. ​    MultiCore* CreateMultiCore() { return new MultiCoreB(); }    
54. };   

​        至此，工厂模式介绍完了。利用Rational Rose 2003软件，给出三种工厂模式的UML图，加深印象。

​         简单工厂模式的UML图：

![img](http://hi.csdn.net/attachment/201108/6/0_13126164442m1F.gif)

​         工厂方法的UML图：

![img](http://hi.csdn.net/attachment/201108/6/0_1312616449DlvG.gif)

​         抽象工厂模式的UML图：

![img](http://hi.csdn.net/attachment/201108/6/0_1312616458PVae.gif)

​       

​       